## 【题目】

给定一个无序的整型数组 arr，找到其中最小的 k 个数。

## 【要求】

如果数组 arr 的长度为 N，排序之后自然可以得到最小的 k 个数，此时时间复杂度与排序的
时间复杂度相同，均为 O(NlogN)。本题要求实现时间复杂度为 O(Nlogk)和 O(N)的方法。

## 【方法一：大顶堆】

O(Nlogk)的方法。说起来也非常简单，就是一直维护一个有 k 个数的大根堆，这个堆代表目 前选出的 k 个最小的数，在堆里的 k 个元素中堆顶的元素是最小的 k 个数里最大的那个。 接下来遍历整个数组，遍历的过程中看当前数是否比堆顶元素小。如果是，就把堆顶的元 素替换成当前的数，然后从堆顶的位置调整整个堆，让替换操作后堆的最大元素继续处在堆顶 的位置；如果不是，则不进行任何操作，继续遍历下一个数；在遍历完成后，堆中的 k 个数就 是所有数组中最小的 k 个数。

## 【方法二：BFPRT 算法】

O(N)的解法。需要用到一个经典的算法——BFPRT 算法，该算法于 1973 年由 Blum、Floyd、 Pratt、Rivest 和 Tarjan 联合发明，其中蕴含的深刻思想改变了世界。

BFPRT 算法解决了这样一个问题：在**时间复杂度 O(N)**内，**从无序的数组中找到第 k 小的数**。显而易见的是，如果我们找到 了第 k 小的数，那么想求 arr 中最小的 k 个数，就是再遍历一次数组的工作量而已

## 【知识补充】

### （1）堆的概念

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217182750011-675658660.png)

**堆**是具有以下性质的**完全二叉树**：
每个结点的值都大于或等于其左右孩子结点的值，称为**大顶堆**；
每个结点的值都小于或等于其左右孩子结点的值，称为**小顶堆**。

我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217182857323-2092264199.png)

![image-20210410221533839](C:\Users\乔帮主\AppData\Roaming\Typora\typora-user-images\image-20210410221533839.png)

### （2）堆排序

学习链接：https://www.cnblogs.com/l199616j/p/10741093.html

一般**升序**采用**大顶堆**，**降序**采用**小顶堆**

简单总结下堆排序的基本思路：

　　a.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;

　　b.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;

　　c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。

### （3）时间复杂度分析

**1. 时间复杂度：**堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)...1]逐步递减，近似为nlogn。所以堆排序时间复杂度最好和最坏情况下都是**O(nlogn)**级。

**2. 空间复杂度：**堆排序不要任何辅助数组，只需要一个辅助变量，所占空间是常数与n无关，所以**空间复杂度为O(1)**。