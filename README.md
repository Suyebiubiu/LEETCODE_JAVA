# LEETCODE_JAVA
### 2020.10.22 leetcode344反转字符串
收获：for和while都可以解决这个问题，熟悉一下语法，双指针遍历，一个从前往后，一个从后往前。

### 2020.10.25 leetcode129  求根到叶子节点数字之和
空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度，最坏情况下，二叉树的高度等于节点个数，

**方法一：** 使用深度优先遍历方法

首先定义一个sum为0，遍历从根结点开始计算dfs(root,sum)，当根节点为空返回，否则，将之前和*10加上现在节点的值，赋值给sum变量。当左右为空时候，返回sum，否则返回dfs(left,sum)+dfs(right,sum)

**方法二：** 使用广度优先遍历

使用java中队列 linkedlist的父类是queue队列：Queue<TreeNode> nodeQueue = new LinkedList<TreeNode>();用到了里面的offer和poll方法
### 2020.11.13 剑指offer02 单例模式
单例模式，写了7种实现方式

### 2020.11.17 剑指offer01 寻找数组中重复的数字
**case1：** 一维数组在内存中占据连续的空间，因此我们可以根据下标定位对应的元素，总时间复杂度是O(n)，空间复杂度是O(1)

**case2：** 不修改数组找出重复的数字，我们可以借助一个辅助数组，需要O(n)空间

**case3：** 不修改数组找出重复的数字，我们尝试使用二分查找方式，如果输入长度n的数组，总时间复杂度为O(nlogn),空间复杂度是O(1)，与case2相比相当于以时间换空间。需要指出这种算法没法找出所有重复的数字

收获：要学会根据面试官要求，是找出任意一个还是全部重复数字，性能上，是时间效率优先还是空间效率优先。选择的算法也是不同的，需要和面试官交流。

### 2020.11.19 剑指offer03 二维数组中查找是否含有某个数字
题目：二维数组中，每一行按照从左到右递增的顺序排序，每一列按照从上到下递增的顺序排序。输入这个二维数组和一个整数，判断数组中是否有这个整数
。

**双指针法：** 双指针法，从右上角入手，小了往下找，大了往左找，相等直接返回（同理可以从左下角入手），时间复杂度是O(mn)，空间复杂度是O(1)

**收获：** 当没有思路的时候，可以试着模拟一下，另外网上还有这个题目的二分法，二分法适合的是排序之后的数组，这里显然是不合适的

### 2020.11.25 剑指offer04 替换字符串中所有空格
 题目：将一个字符串中空格替换为20%
 
 JAVA中string字符串是不可变的，我们可以利用可变的字符串StringBuffer

**case1：** 使用StringBuffer

**case2：** 使用StringBuilder

**case3：** 创建一个新的char[] ,从后往前复制

### 2020.11.27 剑指offer05 链表从后往前打印

**case1：** 使用Stack的先进后出的特点

**case2：** 使用递归的方式，本质上还是个栈

另外，链表的类：
```
    public class ListNode {
        public ListNode next;
        public int val;
 
        public ListNode(int val) {
            this.val = val;
     }
    } 
```
### 2020.


